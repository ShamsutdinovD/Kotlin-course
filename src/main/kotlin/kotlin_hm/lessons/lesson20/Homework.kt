package kotlin_hm.kotlin_hm.lessons.lesson20

import kotlin.math.absoluteValue


//1.Определите функцию-расширение для массива чисел, которая не принимает аргументов и возвращает пару
// из чисел - первое и последнее. Если массив был пуст то вернуть пару из null значений.

fun Array<Int>.fun1() : Pair<Int?, Int?> {
    if (isEmpty()) {
        return null to null
    } else {
        return first() to last()
    }
}

//2. Создайте функцию-расширение для изменяемого списка элементов:
//- с дженериком T ограниченным интерфейсом Comparable<T>
//- которая принимает булево значение
//- возвращает этот же список только в виде неизменяемого
//- сам изменяемый список при этом должен стать отсортированным по возрастанию, если в функцию передано true и по
// убыванию, если false (используем функции sort() и sortDescending()

fun <T: Comparable<T>> MutableList<T>.fun2 (arg1: Boolean) : List<T> {
    val self = toList()
    if (arg1) {
        sort()
    } else {
        sortDescending()
    }
    return self
}

//3. Создайте функцию-расширение для nullable словаря с дженериком:
//- Ключ является дженериком
//- Значение является списком из дженериков
//- Принимает целое число
//- Возвращает nullable словарь из ключей изначального словаря приведённых к строке через toString()
//- Значений из nullable дженерика, взятых из изначального ключа-списка по индексу из аргумента, если такого
// индекса нет - значением будет null

fun <K> Map<K, List<K>>?.fun2 (arg: Int) : Map<String, K?>? {
    return this?.mapKeys { it.key.toString() }
        ?.mapValues { it.value.getOrNull(arg) }
}

//4.Реализуйте метод расширения within для класса Number, который проверяет, что текущее число отклоняется от
// эталонного не более допустимого значения. Метод принимает два параметра: other — число для сравнения и deviation —
// максимально допустимое отклонение. Метод должен возвращать true, если разница между текущим числом и числом для
// сравнения не превышает заданное отклонение. Протестируйте функцию на разных типах чисел. Для получения отклонения,
// у разницы чисел нужно вызвать свойство absoluteValue.

fun Number.within(other: Number, deviation: Number): Boolean {
    val actual = toDouble() - other.toDouble()
    return actual.absoluteValue <= deviation.toDouble()
}